/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All data is
 * considered private and is only accessible by the authenticated user who owns it.
 * This prevents any user from seeing or interacting with another user's data.
 *
 * Data Structure: All application data is organized hierarchically under a top-level
 * `/users` collection. Each user's data, including their profile, login history,
 * and signup records, is stored in a document tree under `/users/{userId}`. This
 * structure makes it simple to apply ownership-based security rules.
 *
 * Key Security Decisions:
 * - User Enumeration is explicitly DISALLOWED. Listing documents in the top-level
 *   `/users` collection is forbidden to protect user privacy.
 * - All subcollections (`logins`, `signups`) are private and can only be read
 *   or modified by the parent user.
 * - The default security posture is to deny all access. Rules are written to
 *   explicitly grant permissions only where intended.
 *
 * Denormalization for Authorization: The security model relies on path-based
 * ownership. A user's UID is part of the document path (e.g., `/users/{userId}/...`),
 * which allows for simple, performant, and secure authorization checks without
 * needing to read other documents (`get()` calls).
 *
 * Structural Segregation: There are no public collections in this model. All
 * data is user-private and segregated by the user's document path.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership on an existing document. Used for safe updates and deletes.
     * Denies requests that target non-existent documents.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that the `id` field within a new user document matches the
     * document's ID (and the user's auth UID). Enforces relational integrity.
     */
    function isCreatingOwnUserDoc(userId) {
      return isOwner(userId) && request.resource.data.id == userId;
    }

    /**
     * Validates that the `userId` field within a new subcollection document
     * (e.g., login, signup) correctly points back to its parent user document.
     */
    function isCreatingOwnSubcollectionDoc(userId) {
      return isOwner(userId) && request.resource.data.userId == userId;
    }

    /**
     * Ensures the user document's primary `id` field cannot be changed after creation.
     */
    function isUserIdImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * Ensures the subcollection document's `userId` foreign key cannot be changed.
     */
    function isUserForeignKeyImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }

    // -------------------------------------------------------------------------
    // Collection Rules
    // -------------------------------------------------------------------------

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow A user (auth.uid='user123') can (create) their own user document at /users/user123.
     * @deny An anonymous user cannot (get) any user document.
     * @deny A logged-in user (auth.uid='user456') cannot (update) another user's document at /users/user123.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isCreatingOwnUserDoc(userId);
      allow update: if isExistingOwner(userId) && isUserIdImmutable();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to a user's login history.
     * @path /users/{userId}/logins/{loginId}
     * @allow A user (auth.uid='user123') can (create) a new login record in their own subcollection.
     * @allow The same user can (list) all documents in their own /logins subcollection.
     * @deny A different user (auth.uid='user456') cannot (get) a login record from /users/user123/logins/{loginId}.
     * @principle Enforces document ownership for all operations on sensitive, user-specific subcollections.
     */
    match /users/{userId}/logins/{loginId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isCreatingOwnSubcollectionDoc(userId);
      allow update: if isExistingOwner(userId) && isUserForeignKeyImmutable();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to a user's signup records.
     * @path /users/{userId}/signups/{signupId}
     * @allow A user (auth.uid='user123') can (create) a new signup record in their own subcollection.
     * @allow The same user can (get) a specific signup record they own.
     * @deny A different user (auth.uid='user456') cannot (delete) a signup record from /users/user123/signups/{signupId}.
     * @principle Enforces document ownership for all operations on sensitive, user-specific subcollections.
     */
    match /users/{userId}/signups/{signupId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isCreatingOwnSubcollectionDoc(userId);
      allow update: if isExistingOwner(userId) && isUserForeignKeyImmutable();
      allow delete: if isExistingOwner(userId);
    }
  }
}